package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"thinkerTools/types"
)

// Env represents the environment configuration
type Env struct {
	BaseURL  string `json:"BASE_URL"`
	Email    string `json:"EMAIL"`
	Password string `json:"PASSWORD"`
}

// ResponseData represents the data section of a response
type ResponseData struct {
	CaseID           string  `json:"case_id"`
	Fields           []Field `json:"fields"`
	AdditionalFields []Field `json:"additional_fields"`
}

// ResponseJSON represents a typical JSON response structure
type ResponseJSON struct {
	Response map[string]interface{} `json:"Response"`
	Status   int                    `json:"Status"`
}

type ApplyProductResponse struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
	Data    struct {
		CaseID           string  `json:"case_id"`
		AnswerToken      string  `json:"answer_token"`
		Field            Field   `json:"field"`
		AdditionalFields []Field `json:"additional_fields"`
	} `json:"data"`
}

type Label struct {
	Text     string `json:"text"`
	ImageURL string `json:"image_url"`
}

type Choice struct {
	Value string           `json:"value"`
	Label map[string]Label `json:"label"`
}

type Field struct {
	FieldName               string           `json:"field_name"`
	DataType                string           `json:"data_type"`
	CurrentValue            string           `json:"current_value"`
	Label                   map[string]Label `json:"label"`
	Choices                 []Choice         `json:"choices"`
	IsMandatory             bool             `json:"is_mandatory"`
	InputSource             string           `json:"input_source"`
	IsMultipleValuesAllowed bool             `json:"is_multiple_values_allowed"`
	Alias                   string           `json:"alias"`
}

type FormData struct {
	CaseID           string  `json:"case_id"`
	Fields           []Field `json:"fields"`
	AdditionalFields []Field `json:"additional_fields"`
}

type GetFullFormResponse struct {
	Code    int      `json:"code"`
	Message string   `json:"message"`
	Data    FormData `json:"data"`
}

var basePath string

// loadJSONFromPath loads JSON from a given file path.
func loadJSONFromPath(path string) (map[string]interface{}, error) {
	filePath := filepath.Join(basePath, path)
	file, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	jsonStr, err := removeComments(string(file))
	if err != nil {
		return nil, err
	}

	var result map[string]interface{}
	err = json.Unmarshal([]byte(jsonStr), &result)
	return result, err
}

// removeComments removes comments from a JSON string.
func removeComments(jsonStr string) (string, error) {
	pattern := `//.*?$|/\*.*?\*/|'(?:(?:\\.|[^'\\])*)'|"(?:(?:\\.|[^"\\])*)"`
	re, err := regexp.Compile(pattern)
	if err != nil {
		return "", err
	}

	cleaned := re.ReplaceAllStringFunc(jsonStr, func(m string) string {
		if strings.HasPrefix(m, `"`) || strings.HasPrefix(m, `'`) {
			return m
		}
		return ""
	})
	return cleaned, nil
}

// makeRequest makes an HTTP request and returns the response.
func makeRequest(client *http.Client, apiURL string, headers map[string]string, payload interface{}) (*ResponseJSON, []byte, error) {
	data, err := json.Marshal(payload)
	if err != nil {
		return nil, nil, err
	}

	req, err := http.NewRequest("POST", apiURL, bytes.NewBuffer(data))
	if err != nil {
		return nil, nil, err
	}

	for key, value := range headers {
		req.Header.Set(key, value)
	}

	fmt.Printf("Sending request to URL: %s with payload: %s\n", apiURL, string(data))

	resp, err := client.Do(req)
	if err != nil {
		return nil, nil, err
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, nil, err
	}

	var responseJSON ResponseJSON
	if err := json.Unmarshal(bodyBytes, &responseJSON); err != nil {
		return nil, bodyBytes, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, bodyBytes, fmt.Errorf("received non-200 status: %d", resp.StatusCode)
	}

	return &responseJSON, bodyBytes, nil
}

func extractCSVData(formData FormData, fieldType string) ([]string, []string) {
	var allFields []Field

	if fieldType == "fields" || fieldType == "all" {
		allFields = append(allFields, formData.Fields...)
	}
	if fieldType == "additional_fields" || fieldType == "all" {
		allFields = append(allFields, formData.AdditionalFields...)
	}

	header := []string{"case_id"}
	exampleDataRow := []string{formData.CaseID}

	for _, field := range allFields {
		formattedFieldName := formatFieldName(field) // Use the formatFieldName function
		header = append(header, formattedFieldName)

		exampleValue := field.CurrentValue
		if exampleValue == "" {
			exampleValue = exampleDataForField(field) // Use the exampleDataForField function
		}
		exampleDataRow = append(exampleDataRow, exampleValue)
	}

	return header, exampleDataRow
}

func formatFieldName(field Field) string {
	formattedName := field.FieldName + "||" + field.DataType
	if field.IsMultipleValuesAllowed {
		formattedName += "||MULTI"
	}
	return formattedName
}

func exampleDataForField(field Field) string {
	switch field.DataType {
	case "date":
		return "DD-MM-YYYY"
	case "date_time":
		return "DD-MM-YYYY hh:mm:ss"
	case "number":
		if field.IsMultipleValuesAllowed {
			return "0\\0"
		}
		return "0"
	case "file":
		if field.IsMultipleValuesAllowed {
			return "test1.pdf\\test2.pdf"
		}
		return "test1.pdf"
	case "text":
		if field.IsMultipleValuesAllowed {
			return "text1\\text2"
		}
		return "text"
	default:
		return ""
	}
}

// writeCSV writes header and rows to a CSV file.
func writeCSV(header []string, row []string, path string) error {
	filePath := filepath.Join(basePath, path)
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	if err := writer.Write(header); err != nil {
		return err
	}
	if err := writer.Write(row); err != nil {
		return err
	}

	return nil
}

func main() {
	basePath, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting current working directory:", err)
		os.Exit(1)
	}

	// Assuming the config file is in a folder named 'config' within the current working directory
	configPath := filepath.Join(basePath, "config", "config.yaml")

	// Load configuration
	config, err := types.LoadConfig(configPath)
	if err != nil {
		fmt.Println("Failed to load configuration:", err)
		os.Exit(1)
	}

	selectedEnv, ok, exit := types.SelectEnvironment(config)
	if !ok {
		if exit {
			fmt.Println("Exiting...")
			os.Exit(0)
		}
		fmt.Println("Invalid environment selection")
		os.Exit(1)
	}

	session := &http.Client{}
	headers, err := types.Authenticate(session, selectedEnv.BaseURL+"/authentication/api/v1/login", selectedEnv.Email, selectedEnv.Password)
	if err != nil {
		fmt.Println("Error during authentication:", err)
		os.Exit(1)
	}

	payload, err := loadJSONFromPath(filepath.Join(basePath, "3. dataSource/productName.json"))
	if err != nil {
		fmt.Println("Failed to load payload:", err)
		os.Exit(1)
	}

	// Apply for product and get the case ID
	responseApplyProduct, applyProductBodyBytes, err := makeRequest(session, selectedEnv.BaseURL+"/question-taskpool/api/v1/apply-for-product", headers, payload)
	if err != nil {
		fmt.Println("Error applying for product:", err)
		os.Exit(1)
	}

	var applyProductResp ApplyProductResponse
	if err := json.Unmarshal(applyProductBodyBytes, &applyProductResp); err != nil {
		fmt.Println("Error unmarshalling apply product response:", err)
		os.Exit(1)
	}

	// Prepare payload for get-full-form request
	payloadGetFullForm := map[string]string{"case_id": applyProductResp.Data.CaseID}
	_, getFullFormBodyBytes, err := makeRequest(session, selectedEnv.BaseURL+"/question-taskpool/api/v1/get-full-form", headers, payloadGetFullForm)
	if err != nil {
		fmt.Printf("Error in get-full-form request: %v\n", err)
		os.Exit(1)
	}

	// Extracting the actual FormData from the response
	var fullFormResponse GetFullFormResponse
	if err := json.Unmarshal(getFullFormBodyBytes, &fullFormResponse); err != nil {
		fmt.Println("Error decoding full form response:", err)
		os.Exit(1)
	}

	// Process and write the data to CSV
	header, row := extractCSVData(fullFormResponse.Data, "all")
	csvFilePath := "output.csv"
	if err := writeCSV(header, row, csvFilePath); err != nil {
		fmt.Println("Error writing to CSV:", err)
		os.Exit(1)
	}

	// Writing to CSV
	if err := writeCSV(header, row, "4. answerAndQuestion/questionAllFields.csv"); err != nil {
		fmt.Printf("Error writing CSV: %v\n", err)
		os.Exit(1)
	}

	responseCounters := make(map[int]int)
	uniqueResponses := make(map[int]map[string]int)

	responseStr, err := json.Marshal(responseApplyProduct.Response)
	if err != nil {
		panic(err)
	}

	status := responseApplyProduct.Status
	responseCounters[status]++

	if uniqueResponses[status] == nil {
		uniqueResponses[status] = make(map[string]int)
	}
	uniqueResponses[status][string(responseStr)]++

	if status == 200 {
		var applyProductResp ApplyProductResponse
		responseBytes, err := json.Marshal(responseApplyProduct.Response)
		if err != nil {
			panic(err)
		}

		err = json.Unmarshal(responseBytes, &applyProductResp)
		if err != nil {
			panic(err)
		}

		caseID := applyProductResp.Data.CaseID

		payloadGetFullForm := map[string]string{"case_id": caseID}

		// Make the request to the get-full-form API
		responseGetFullForm, bodyBytes, err := makeRequest(session, selectedEnv.BaseURL+"/question-taskpool/api/v1/get-full-form", headers, payloadGetFullForm)
		if err != nil {
			fmt.Printf("Error in get-full-form request: %v\n", err)
			os.Exit(1)
		}

		// Check if the status code is OK
		if responseGetFullForm.Status != http.StatusOK {
			fmt.Println("Non-200 status received:", responseGetFullForm.Status)
			os.Exit(1)
		}

		// Extracting the actual FormData from the response
		var fullFormResponse GetFullFormResponse
		if err := json.Unmarshal(bodyBytes, &fullFormResponse); err != nil {
			fmt.Println("Error decoding full form response:", err)
			os.Exit(1)
		}

		// Debug print to check if fields are correctly populated
		fmt.Printf("Decoded FormData: %+v\n", fullFormResponse.Data)
		fmt.Printf("Number of regular fields: %d\n", len(fullFormResponse.Data.Fields))
		fmt.Printf("Number of additional fields: %d\n", len(fullFormResponse.Data.AdditionalFields))

		// Now pass the correct FormData to extractCSVData
		headerAll, rowAll := extractCSVData(fullFormResponse.Data, "all")
		if err := writeCSV(headerAll, rowAll, "4. answerAndQuestion/questionAllFields.csv"); err != nil {
			fmt.Printf("Error writing CSV: %v\n", err)
			os.Exit(1)
		}

		headerFields, rowFields := extractCSVData(fullFormResponse.Data, "fields")
		if err := writeCSV(headerFields, rowFields, "4. answerAndQuestion/questionMandatoryFields.csv"); err != nil {
			panic(err)
		}

		headerAddFields, rowAddFields := extractCSVData(fullFormResponse.Data, "additional_fields")
		if err := writeCSV(headerAddFields, rowAddFields, "4. answerAndQuestion/questionAdditionalFields.csv"); err != nil {
			panic(err)
		}
	} else {
		fmt.Printf("Received non-200 status from apply for product: %d\n", responseApplyProduct.Status)
		os.Exit(1)
	}

	// Print summary of responses
	for status, count := range responseCounters {
		fmt.Printf("status %d : %d Requests.\n", status, count)
		fmt.Println("detail of", status, ":")
		for responseStr, occurrence := range uniqueResponses[status] {
			fmt.Printf("Occurrences: %d\n", occurrence)
			fmt.Println("Response:", responseStr)
			fmt.Println("----------------------")
		}
	}
}
